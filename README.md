# Репозиторий структур данных и алгоритмов на Python

Этот репозиторий содержит реализации базовых структур данных и алгоритмов на Python. Он ориентирован на изучение основ информатики с практическими примерами и тестами. Код написан на Python 3 с использованием стандартных библиотек, где это возможно.

Репозиторий разделён на две основные категории: **Структуры данных** (блоки для хранения и организации данных) и **Алгоритмы** (методы обработки и манипуляции данными, часто с указанием сложности по Big O).

## Структуры данных

Эти файлы содержат реализации популярных структур данных с основными методами, такими как вставка, удаление, поиск и обход.

### Стек (stack.py)

- **Описание**: Реализация стека на основе списка, работающего по принципу LIFO (Last In, First Out).
- **Основные методы**:
  - `push(item)`: Добавляет элемент в вершину стека.
  - `pop()`: Удаляет и возвращает верхний элемент.
  - `is_empty()`: Проверяет, пуст ли стек.
- **Пример использования**: Проверка сбалансированности скобок в строке (например, `[(()[][()])]` → `True`, `[(()]` → `False`).
- **Сложность**:
  - `push`: O(1)
  - `pop`: O(1)
  - `is_empty`: O(1)

### Очередь (queue\_.py)

- **Описание**: Реализация очереди с использованием `collections.deque`, работающей по принципу FIFO (First In, First Out).
- **Основные методы**:
  - `enqueue(item)`: Добавляет элемент в конец очереди.
  - `dequeue()`: Удаляет и возвращает первый элемент.
  - `peek()`: Возвращает первый элемент без удаления.
  - `is_empty()`: Проверяет, пуста ли очередь.
- **Пример использования**: Обработка игровых запросов (например, `"Player1: Move"`) и сообщений чата в порядке поступления.
- **Сложность**:
  - `enqueue`: O(1)
  - `dequeue`: O(1)
  - `peek`: O(1)
  - `is_empty`: O(1)

### Хэш-таблица (hash.py)

- **Описание**: Хэш-таблица с разрешением коллизий через списки (chaining). Использует встроенную функцию `hash()` для вычисления индекса.
- **Основные методы**:
  - `put(key, value)`: Добавляет или обновляет пару ключ-значение.
  - `get(key)`: Возвращает значение по ключу или `None`, если ключ отсутствует.
  - `remove(key)`: Удаляет пару ключ-значение.
  - `print_table()`: Выводит содержимое таблицы.
- **Пример использования**: Хранение пар ключ-значение (например, `"apple": 5`, `"banana": 10`) с обработкой коллизий (например, `"ape"` и `"apple"` могут попасть в одну ячейку).
- **Сложность**:
  - `put`: O(1) в среднем, O(n) в худшем случае (при коллизиях).
  - `get`: O(1) в среднем, O(n) в худшем случае.
  - `remove`: O(1) в среднем, O(n) в худшем случае.

### Бинарное дерево поиска (tree.py)

- **Описание**: Реализация бинарного дерева поиска (BST) с узлами, содержащими значение и ссылки на левое/правое поддерево.
- **Основные методы**:
  - `insert(value)`: Вставляет значение в дерево.
  - `search(value)`: Ищет узел с заданным значением.
  - `delete(value)`: Удаляет узел с заданным значением (обрабатывает случаи: лист, один потомок, два потомка).
  - `_find_min(node)`: Находит минимальное значение в поддереве.
- **Пример использования**: Хранение рейтингов игроков (например, `[10, 15, 11, 20, 30, ...]`) с поиском (например, `20` найдено, `14` не найдено).
- **Сложность**:
  - `insert`: O(h), где h — высота дерева (O(log n) в среднем, O(n) в худшем случае).
  - `search`: O(h)
  - `delete`: O(h)

### Граф (graph.py)

- **Описание**: Реализация ненаправленного графа с использованием списка смежности (`collections.defaultdict`).
- **Основные методы**:
  - `add_edge(u, v)`: Добавляет ребро между вершинами `u` и `v`.
  - `bfs(start)`: Выполняет обход в ширину (BFS) от заданной вершины.
  - `print_graph()`: Выводит список смежности.
- **Пример использования**: Построение графа с рёбрами (например, `A-B`, `A-C`, `A-D`) и обход BFS (вывод: `A B C D`).
- **Сложность**:
  - `add_edge`: O(1)
  - `bfs`: O(V + E), где V — вершины, E — рёбра.
  - `print_graph`: O(V + E)

## Алгоритмы

Эти файлы содержат реализации алгоритмов с анализом их временной сложности и замерами времени выполнения (с помощью декоратора `@timeit`).

### Общие алгоритмы (algo.py)

- **Описание**: Класс `BigO` с реализациями базовых алгоритмов и декоратором `@timeit` для замера времени выполнения.
- **Алгоритмы**:
  - `find_max(data)`: Поиск максимального числа в списке.
    - **Сложность**: O(n)
    - **Пример**: Поиск максимума в `[1, 5, 3, 9, 2]` → `9`.
  - `unique_words(text)`: Возвращает список уникальных слов из строки.
    - **Сложность**: O(n) для прохода по словам, O(k) для проверки `in` (k — длина уникального списка).
    - **Пример**: `unique_words("hello world hello")` → `["hello", "world"]`.
  - `linear_search(items, target)`: Линейный поиск индекса элемента.
    - **Сложность**: O(n) в худшем случае, O(1) в лучшем.
    - **Пример**: `linear_search([1, 2, 3], 2)` → `1`.
  - `bubble_sort(data)`: Пузырьковая сортировка.
    - **Сложность**: O(n²) в среднем и в худшем случае.
    - **Пример**: `bubble_sort([5, 2, 8, 1])` → `[1, 2, 5, 8]`.
  - `quick_sort(data)`: Быстрая сортировка с использованием опорного элемента (pivot).
    - **Сложность**: O(n log n) в среднем, O(n²) в худшем случае.
    - **Пример**: `quick_sort([5, 2, 8, 1])` → `[1, 2, 5, 8]`.

### Бинарный поиск (algo.py)

- **Описание**: Класс `BinarySearch` с реализациями итеративного и рекурсивного бинарного поиска для отсортированного массива.
- **Методы**:
  - `search(arr, target)`: Итеративный бинарный поиск.
  - `search_recursive(arr, target, left, right)`: Рекурсивный бинарный поиск.
- **Сложность**: O(log n) для обоих методов.
- **Пример**: `search([1, 2, 3, 4], 3)` → `2`, `search([1, 2, 3, 4], 5)` → `-1`.

## Установка и использование

1. Убедитесь, что у вас установлен Python 3.6+.

2. Склонируйте репозиторий:

   ```bash
   git clone <URL_репозитория>
   ```

3. Перейдите в папку проекта:

   ```bash
   cd <папка_репозитория>
   ```

4. Запустите любой файл, например:

   ```bash
   python hash.py
   ```

Для замеров времени выполнения алгоритмов (`algo.py`) требуется модуль `time` и `logging` (входят в стандартную библиотеку Python).